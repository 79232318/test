（其实是乐观锁，获取不加锁，改变的时候加锁）
线程1获取轻量级锁时会先把锁对象的*对象头MarkWord复制一份*到线程1的栈帧中创建的用于存储锁记录的空间（称为DisplacedMarkWord），
然后使用CAS把对象头中的内容替换为线程1存储的锁记录（DisplacedMarkWord）的地址；

如果在线程1复制对象头的同时（在线程1CAS之前），线程2也准备获取锁，复制了对象头到线程2的锁记录空间中，但是在线程2CAS的时候，发现线程1已经把对象头换了，线程2的CAS失败，
那么线程2就尝试使用自旋锁来等待线程1释放锁。

但是如果自旋的时间太长也不行，因为自旋是要消耗CPU的，因此自旋的次数是有限制的，比如10次或者100次，
如果自旋次数到了线程1还没有释放锁，或者线程1还在执行，线程2还在自旋等待，这时又有一个线程3过来竞争这个锁对象，
那么这个时候轻量级锁就会膨胀为重量级锁。重量级锁为了防止CPU空转，把除了拥有锁的线程都阻塞。

 

*注意：
为了避免无用的自旋，轻量级锁一旦膨胀为重量级锁就不会再降级为轻量级锁了；
偏向锁升级为轻量级锁也不能再降级为偏向锁。一句话就是锁可以升级不可以降级，但是偏向锁状态可以被重置为无锁状态。
