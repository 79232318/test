/**  
* @Title: Version1.java  
* @Package com.排序算法.选择排序  
* @Description: TODO(用一句话描述该文件做什么)  
* @author wangtz  
* @date 2019年10月8日  
* @version V1.0  
*/  
package com.排序算法.插入排序.直接插入;

import java.util.Arrays;

/**  
* <p>Description: </p>
* @ClassName: Version1  
* @author wangtz  
* @date 2019年10月8日    
*/
public class Version1 {

	/**
	  * 插入排序（Insertion sort）是一种简单直观且稳定的排序算法。如果有一个已经有序的数据序列，
	  * 要求在这个已经排好的数据序列中插入一个数，但要求插入后此数据序列仍然有序，
	  * 这个时候就要用到一种新的排序方法——插入排序法,插入排序的基本操作就是将一个数据插入到已经排好序的有序数据中，
	  * 从而得到一个新的、个数加一的有序数据，算法适用于少量数据的排序，时间复杂度为O(n^2)。是稳定的排序方法。
	  * 插入算法把要排序的数组分成两部分：第一部分包含了这个数组的所有元素，但将最后一个元素除外（让数组多一个空间才有插入的位置），
	  * 而第二部分就只包含这一个元素（即待插入元素）。在第一部分排序完成后，再将这个最后元素插入到已排好序的第一部分中。
	  * 插入排序的基本思想是：每步将一个待排序的记录，按其关键码值的大小插入到前面已经排序的数组中的适当位置上，直到全部插入完为止。
	 */
	public static void main(String[] args) {
//		int[] arr = { 3, 44, 38, 5, 47, 15, 36, 26, 27, 2, 46, 4, 19, 50, 48 };
		int[] arr = { 10, 1, 2, 3, 4, 5, 6, 7, 8, 9};
		//记录排序操作次数
		int count = 0;
		//因为数组元素我们并不确定，所以只能将数组的第一个元素看成是一个有序的序列，
		//所以从数组的第二个元素开始才是我们需要去寻找插入位置的元素
		for (int i = 1; i < arr.length; i++) {
			
			//将初始值取出
			int value = arr[i];
			int index = i - 1;
			//去跟前面的值一个一个的比较，大于初始值的就往后移
			
			while(index >= 0 && arr[index] > value ){
				arr[index + 1] = arr[index];//往后移
				index--;
				count++;
			}
			arr[index + 1] = value;
			
		}
		System.out.println(Arrays.toString(arr));
		System.out.println("一共后移了:" + count + "次");
	}
	/**
	 * 那么在这里，因为数组元素我们并不确定，所以只能将数组的第一个元素看成是一个有序的序列，
	 * 所以从数组的第二个元素开始才是我们需要去寻找插入位置的元素。所以外层循环从1开始，
	 * 然后将arr[i]，也就是当前的第二个元素先保存起来，然后找到待插入元素的前一个元素下标，
	 * 也就是i-1，此时通过一个while循环去比较。当insertIndex小于0时应该退出循环，
	 * 因为此时已经与前面的所有元素比较完毕。在比较的过程中，如果待插入元素小于前一个元素，
	 * 就将前一个元素后移，也就是将前一个元素的值直接赋值给待插入元素位置。
	 * 因为在最开始已经将待插入元素进行了保存，所以只需将待插入元素的值赋值给它的前一个元素即可。
	 * 因为在while循环中insertIndex执行了自减操作，所以它的前一个元素下标应为insertIndex + 1。
	 * 而如果待插入的元素值大于前一个元素，那么就不会进入while循环，这样insertIndex + 1之后的位置仍然是自己所在的位置，
	 * 所以赋值后值不改变，后面的操作以此类推
	 */
	

}
